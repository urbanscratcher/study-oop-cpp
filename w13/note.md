# Week 13. Audio function
## JUCE 애플리케이션 구조 분석
 - JUCE 프로젝트의 코드 구조를 분석하여 애플리케이션이 어떻게 시작되고 실행되는지를 이해하는 과정을 보여줍니다.

### 시작 지점 찾기
- main.cpp 파일을 살펴보며 시작 지점을 찾으려 했으나 main 함수가 없음을 발견.
- 대신 START_JUCE_APPLICATION 매크로를 발견하고 이를 통해 애플리케이션이 시작됨을 확인.

### 매크로 이해
- 매크로는 컴파일 전에 코드 생성 또는 수정에 사용됨.
- 다양한 플랫폼에서 작동할 수 있도록 매크로를 사용해 플랫폼별로 적합한 코드를 생성.

### 매크로 작동 방식 예제
- 간단한 매크로 정의와 그 작동 방식을 예제로 설명.
- g++ -E 명령어를 사용해 전처리된 코드를 확인할 수 있음.

### JUCE 매크로 분석
- START_JUCE_APPLICATION 매크로가 juce_initialization.h 파일을 호출함을 확인.
- 여러 매크로 호출을 통해 최종적으로 main 함수가 정의됨.

### JUCE 애플리케이션 초기화 과정
- JUCEApplicationBase::createInstance를 호출하여 애플리케이션을 인스턴스화하고 초기화하는 과정 설명.
- MainWindow 객체 생성 및 초기화 과정.
- setContentOwned를 통해 메인 컴포넌트를 설정하고 이를 통해 코드가 실행됨.

## 매크로
- C++에서 매크로는 전처리기를 사용하여 컴파일 전에 코드를 변환하거나 삽입하는 기능을 제공합니다.
  - 상수 정의: 값이 변하지 않는 상수를 정의하여 코드에서 반복적으로 사용할 수 있습니다.
  - 코드 블록 정의: 반복적인 코드 블록을 매크로로 정의하여 코드의 재사용성을 높입니다.
  - 조건부 컴파일: 특정 조건에 따라 코드의 일부를 컴파일할지 여부를 결정할 수 있습니다. 예를 들어, 디버그 모드에서만 특정 코드를 실행하도록 할 수 있습니다.
  - 플랫폼별 코드 처리: 서로 다른 운영 체제나 환경에서 다른 코드를 실행할 수 있도록 지원합니다.
  - 복잡한 코드 처리: 복잡하거나 반복적인 코드를 단순하게 만들기 위해 매크로를 사용할 수 있습니다.

## JUCE 메인 컴포넌트 클래스 분석 
- JUCE 애플리케이션의 메인 컴포넌트 클래스 구조를 분석하여 해당 클래스가 어떻게 작동하는지 이해하는 과정을 설명합니다.

### 주요 내용
1. **클래스 상속 구조**:
   - `MainComponent` 클래스는 `AudioAppComponent`를 상속받으며, 이는 `Component`와 `AudioSource` 클래스를 상속받음.
   - `Component` 클래스는 GUI 관련 기능을 제공하고, `AudioSource` 클래스는 오디오 관련 기능을 제공함.

2. **Component 클래스의 함수들**:
   - **`paint` 함수**: 컴포넌트의 그리기 코드를 구현. 기본적으로 배경을 회색으로 채움.
   - **`resized` 함수**: 서브 컴포넌트의 크기를 설정하여 레이아웃을 조정.
   - `paint`와 `resized`는 가상 함수이지만 순수 가상 함수는 아님. 따라서 구현하지 않아도 기본 동작이 있음.

3. **AudioSource 클래스의 함수들**:
   - **`prepareToPlay` 함수**: 오디오 재생 준비를 위한 초기화 작업을 수행. 순수 가상 함수이므로 반드시 구현해야 함. (문서에는 void virtual AudioSource()**=0**)
   - **`releaseResources` 함수**: 사용된 자원을 해제. 순수 가상 함수이므로 반드시 구현해야 함.
   - **`getNextAudioBlock` 함수**: 다음 오디오 블록을 생성. 순수 가상 함수이므로 반드시 구현해야 함. 기본 구현에서는 버퍼를 0으로 채워` 무음을 생성.

4. **함수 구현**:
   - `prepareToPlay`와 `releaseResources`는 기본적으로 빈 함수로 구현되 있음.
   - `getNextAudioBlock`은 기본적으로 버퍼를 0으로 채워 무음을 생성.


### 이벤트 리스너 패턴 (Event Listener Pattern)
- 사용자 인터페이스나 시스템에서 발생하는 이벤트를 감지하고 처리하는 디자인 패턴
- 이 패턴은 주로 GUI 응용 프로그램에서 사용되며, 사용자 상호작용이나 시스템 이벤트에 대한 응답을 비동기적으로 처리할 수 있게 함

### 등록
- 이벤트 리스너가 이벤트를 받기 전에 버튼에 자신을 등록(register)해야 합니다. 즉, "나는 이벤트 리스너입니다. 당신의 이벤트를 받고 싶습니다."라고 버튼에 알려야 합니다.

### 주요 구성 요소

1. **이벤트 소스(Event Source)**: 이벤트가 발생하는 객체. 예를 들어, 버튼, 텍스트 입력 필드 등.
2. **이벤트(Event)**: 이벤트 소스에서 발생하는 특정 행동이나 상태 변화. 예를 들어, 버튼 클릭, 텍스트 입력 등.
3. **이벤트 리스너(Event Listener)**: 이벤트를 감지하고 처리하는 객체. 이벤트 리스너는 이벤트 소스에 등록되어 특정 이벤트가 발생했을 때 호출됨.
4. **이벤트 핸들러(Event Handler)**: 이벤트 리스너가 이벤트를 처리하는 메서드. 이벤트가 발생하면 이벤트 핸들러가 호출되어 필요한 작업을 수행함.

### 동작 원리

1. **이벤트 등록(Registration)**: 이벤트 리스너는 이벤트 소스에 자신을 등록함. 이는 "나는 당신의 이벤트를 듣고 싶습니다"라고 알리는 과정.
2. **이벤트 발생(Event Generation)**: 이벤트 소스에서 특정 이벤트가 발생함. 예를 들어, 사용자가 버튼을 클릭함.
3. **이벤트 통지(Notification)**: 이벤트 소스는 등록된 이벤트 리스너들에게 이벤트가 발생했음을 알림.
4. **이벤트 처리(Event Handling)**: 이벤트 리스너는 이벤트를 받고, 미리 정의된 이벤트 핸들러를 통해 이벤트를 처리함.

### 예제

```javascript
// 이벤트 소스: 버튼
const button = document.querySelector('button');

// 이벤트 리스너 등록
button.addEventListener('click', function(event) {
    // 이벤트 핸들러: 클릭 이벤트 처리
    alert('Button was clicked!');
});
```

## 순수 가상 함수 (Pure Virtual Functions)
- `virtual void overrideMe() = 0;`와 같이 선언된 함수로, 이 함수는 해당 클래스에서 반드시 자식 클래스에 의해 재정의되어야 함
- 즉, 순수 가상 함수가 하나라도 포함된 클래스는 추상 클래스가 되며, 이 클래스의 인스턴스를 직접 생성할 수 없음

### 추상 클래스 (Abstract Class)

- 순수 가상 함수를 1개 이상 포함하는 클래스
- 추상 클래스는 직접 인스턴스화할 수 없으며, 이를 상속받는 자식 클래스에서 순수 가상 함수를 구현해야 함

### 순수 가상 함수와의 차이점

- 코드에서 주석 처리된 `virtual void overrideMe() {};` 부분은 순수 가상 함수가 아닌 일반 가상 함수임
- 이 경우 자식 클래스에서 재정의하지 않아도 컴파일 에러가 발생하지 않음
- 하지만, 순수 가상 함수는 자식 클래스에서 반드시 구현해야 함


