# Week 14. 사운드

## 디지털 사운드 기본 개념
### 소리의 디지털 표현
- 소리는 컴퓨터 내부에서 **숫자**로 표현될 수 있으며, 이 숫자들은 시간에 따라 다이어프램[^1], 스피커 또는 헤드폰의 이동을 나타냄
- 마이크로폰은 소리를 **아날로그 전압**으로 변환하고, 이 전압은 **아날로그-디지털 변환기**를 통해 주기적으로 샘플링되어 디지털 숫자로 저장됨

### 샘플링과 녹음
- 마이크로폰은 음압을 다이어프램의 이동으로 변환하고, 이 움직임은 **전압의 변화**로 변환됨
- 이 전압 변화는 아날로그-디지털 변환기를 통해 주기적으로 샘플링되며, 샘플링된 값들은 숫자의 배열로 컴퓨터에 저장됨

### 사운드 재생
- 저장된 숫자 배열은 다시 **디지털-아날로그 변환기**를 통해 **전압**으로 변환되어 스피커나 헤드폰을 움직여 소리를 재생함
- CD 품질의 오디오는 초당 44,100회 샘플링함

### 버퍼 사용
- 소리를 재생할 때, 숫자를 하나씩 전송하는 대신, 버퍼라는 **고정 크기의 숫자 블록**을 사용하여 효율성을 높임
- 오디오 프로그램은 큰 숫자 배열을 **작은 버퍼**로 나누어 전송함

### 숫자의 생성 방법
1. 샘플링
- 마이크로폰을 통해 실제 소리를 녹음하여 숫자로 변환
2. 알고리즘적 생성
- 수학적 알고리즘을 통해 실시간으로 숫자를 생성
  - 예: 주파수 변조 합성(FM synthesis)

## 실시간 사운드 합성
### 주요 개념 및 함수
- Audio Source 클래스: AudioAppComponent는 AudioSource를 상속받아 3가지 순수 가상 함수를 구현해야 함
  - prepareToPlay: 오디오 재생을 준비하는 함수
  - releaseResources: 오디오 자원을 해제하는 함수
  - getNextAudioBlock: 주기적으로 호출되어 버퍼를 채우는 함수로, 이 함수에서 실제 사운드 합성이 이루어짐
- 
### 실시간 사운드 합성 과정
1. 랜덤 노이즈 생성기 구현
   - JUCE::Random 클래스를 사용해 랜덤 숫자를 생성
   - getNextAudioBlock 함수에서 버퍼를 랜덤 숫자로 채움
2. 사운드 재생 및 주의 사항
   - 사운드 합성 과정에서 예상치 못한 큰 소리가 발생할 수 있으므로 헤드폰을 사용하지 않거나 소리를 낮춰서 확인
   - 코드를 실행하면 **랜덤 노이즈(화이트 노이즈)** 소리가 재생됨
3. 피치 톤 생성 (Sawtooth)
  - Sawtooth 파형을 생성하기 위해 phase 변수를 도입
  - phase를 이용해 Sawtooth 파형을 생성하고, 이를 getNextAudioBlock 함수에서 사용
  - 주파수를 조절하기 위해 슬라이더를 추가하여 dphase 값을 변경
4. 순수 톤 생성 (Sine)
  - Sawtooth 파형 대신 Sine 파형을 사용해 부드러운 톤 생성
  - Sine 함수를 사용하여 부드러운 사운드를 생성하고, 이를 버퍼에 채움

## 오디오 파일
### 오디오 파일의 구조
- 오디오 파일은 주기적인 파형으로 구성되며, 시간(x축)과 숫자 값(y축)으로 표현됨
- 스테레오 오디오 파일은 왼쪽 및 오른쪽 채널로 구성됨
### 오디오 파일의 형식
- 다양한 오디오 파일 형식이 존재하며, MP3, WAV, AIFF, MPEG-4 등이 있음
- MP3는 압축 오디오 형식이며, 로드 시 압축을 풀어야 함
### JUCE의 역할
- JUCE는 다양한 오디오 파일 형식을 직접 읽을 수 있는 구성 요소를 제공함
- 이는 사용자가 직접 MP3 디컴프레서나 WAV 파서를 작성할 필요 없이, 쉽게 원시 데이터를 얻고 이를 사운드 카드에 전달할 수 있게 함

## JUCE에서 오디오 파일 재생
#### 컴포넌트 추가
- AudioFormatManager: 다양한 오디오 포맷을 관리하는 첫 번째 레이어
- AudioFormatReaderSource: 오디오 파일을 읽는 두 번째 레이어. 파일을 읽고 오디오 소스로 변환함
- AudioTransportSource: 오디오 재생을 제어하는 세 번째 레이어. 재생, 정지, 탐색 등의 기능을 제공함
#### 코드 작성
- prepareToPlay 함수에서 formatManager를 초기화하여 기본 오디오 포맷을 등록함
- URL을 사용하여 하드코딩된 오디오 파일을 로드함
- AudioFormatReaderSource를 스마트 포인터(std::unique_ptr)로 생성하여 메모리 관리를 용이하게 함
- transportSource를 사용하여 오디오 재생을 제어하고, prepareToPlay를 호출하여 초기화함
#### 오디오 블록 처리
- getNextAudioBlock 함수에서 transportSource를 호출하여 오디오 데이터를 오디오 시스템에 전달함
- releaseResources를 호출하여 오디오 자원을 해제함
#### 실행 및 검토
- 코드를 컴파일하고 실행하여 MP3 파일이 재생되는지 확인함
- 여러 레이어로 구성된 오디오 재생 시스템을 구현하여 오디오 파일을 재생할 수 있게 함

## 사용한 클래스 리뷰
### AudioFormatManager
- **역할**: 다양한 오디오 포맷을 인식하고, 해당 포맷을 읽을 수 있는 객체를 생성
- **기능**: MP3 파일을 압축 해제하여 숫자의 스트림으로 변환하거나, WAV 파일의 헤더를 읽고 채널을 구분하는 등의 작업을 처리

### AudioFormatReader
- **역할**: AudioFormatManager를 통해 생성된 파일 리더로, 실제 파일을 읽는 역할
- **특징**: MP3 리더나 WAV 리더 등 다양한 클래스가 존재하지만, 인터페이스는 동일하여 일관된 방법으로 파일을 처리

### AudioFormatReaderSource
- **역할**: AudioFormatReader를 사용하여 저수준 파일 리더를 오디오 라이프 사이클과 통합
- **기능**: 원하는 구조로 오디오 블록을 추출

### TransportSource
- **역할**: 오디오 재생 제어 기능 추가
- **기능**: 오디오 재생의 시작, 정지 및 볼륨 조절

### ResamplingAudioSource
- **역할**: 재생 속도 변경 기능 추가
- **기능**: DJ 애플리케이션에서 두 트랙의 속도를 맞추기 위해 속도를 조절


[^1]: 다이어프램은 마이크로폰이나 스피커에서 소리의 진동을 전기 신호로 변환하거나 전기 신호를 소리로 변환하는 얇은 막임
